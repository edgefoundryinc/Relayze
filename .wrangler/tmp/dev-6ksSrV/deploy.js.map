{
  "version": 3,
  "sources": ["../../../src/debug/trace.ts", "../../../src/shared/storage.ts", "../../../src/shared/handler.ts", "../../../src/shared/reciever.ts", "../../../src/shared/rate-limiter.ts", "../../../deploy.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-1fb7cZ/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-1fb7cZ/middleware-loader.entry.ts"],
  "sourceRoot": "C:\\Users\\Local_Account\\Documents\\EFGH\\Posthook\\.wrangler\\tmp\\dev-6ksSrV",
  "sourcesContent": ["import type { TraceRecord, EnvRecord, StepRecord, Context } from '../../types/types'\n\nconst log: TraceRecord[] = []\n\n// Track state per trace to enforce step pairing\ntype NodeState = {\n  currentStatus: 'idle' | 'entered' | 'exited' | 'errored'\n  lastStepId: number\n}\n\ntype TraceState = {\n  nodes: Map<StepRecord['node'], NodeState>\n  lastStepId: number\n  env_id: string\n  hasCriticalError: boolean\n}\n\nconst traceStates = new Map<string, TraceState>()\n\nexport function createEnv(payload: EnvRecord['payload']): Context {\n  const trace_id = `tr_${Date.now()}_${Math.random().toString(36).slice(2)}`\n  const env_id = `env_${Date.now()}_${Math.random().toString(36).slice(2)}`\n  \n  // Validate payload\n  if (!payload || typeof payload !== 'object') {\n    throw new Error('createEnv: payload must be a valid object')\n  }\n  \n  log.push({\n    type: 'env',\n    env_id,\n    trace_id,\n    ts: Date.now(),\n    source: 'webhook',\n    payload\n  })\n  \n  // Initialize trace state\n  traceStates.set(trace_id, {\n    nodes: new Map(),\n    lastStepId: 0,\n    env_id,\n    hasCriticalError: false\n  })\n  \n  return Object.freeze({ trace_id, env_id, step_id: 0 })\n}\n\nexport function step(ctx: Context, node: StepRecord['node'], status: StepRecord['status'] = 'enter', meta?: StepRecord['meta']): Context {\n  // Guard 1: Validate context exists and is valid\n  if (!ctx || typeof ctx !== 'object') {\n    throw new Error('step: invalid context')\n  }\n  \n  if (!ctx.trace_id || !ctx.env_id) {\n    throw new Error('step: context missing trace_id or env_id')\n  }\n  \n  // Guard 2: Check if trace state exists\n  const traceState = traceStates.get(ctx.trace_id)\n  if (!traceState) {\n    throw new Error(`step: no trace state found for trace_id ${ctx.trace_id}`)\n  }\n  \n  // Guard 3: Validate env_id hasn't been tampered with\n  if (ctx.env_id !== traceState.env_id) {\n    throw new Error(`step: env_id mismatch - expected ${traceState.env_id}, got ${ctx.env_id}`)\n  }\n  \n  // Guard 4: Validate step_id is sequential\n  if (typeof ctx.step_id !== 'number' || ctx.step_id < 0) {\n    throw new Error(`step: invalid step_id ${ctx.step_id} - must be non-negative number`)\n  }\n  \n  if (ctx.step_id !== traceState.lastStepId) {\n    throw new Error(`step: step_id out of sequence - expected ${traceState.lastStepId}, got ${ctx.step_id}`)\n  }\n  \n  // Guard 5: Cannot continue after critical error\n  if (traceState.hasCriticalError) {\n    throw new Error(`step: trace ${ctx.trace_id} is in error state, cannot continue`)\n  }\n  \n  // Get or create node state\n  if (!traceState.nodes.has(node)) {\n    traceState.nodes.set(node, { currentStatus: 'idle', lastStepId: -1 })\n  }\n  const nodeState = traceState.nodes.get(node)!\n  \n  // Guard 6: Enforce state machine for enter/exit/error\n  if (status === 'enter') {\n    if (nodeState.currentStatus === 'entered') {\n      throw new Error(`step: node '${node}' already entered - must exit before entering again`)\n    }\n  } else if (status === 'exit') {\n    if (nodeState.currentStatus !== 'entered') {\n      throw new Error(`step: node '${node}' cannot exit - not currently entered (status: ${nodeState.currentStatus})`)\n    }\n  } else if (status === 'error') {\n    if (nodeState.currentStatus !== 'entered') {\n      throw new Error(`step: node '${node}' cannot error - not currently entered (status: ${nodeState.currentStatus})`)\n    }\n    // Mark trace as having critical error\n    traceState.hasCriticalError = true\n  }\n  \n  // Log the step\n  const newStepId = ctx.step_id + 1\n  log.push({\n    type: 'step',\n    trace_id: ctx.trace_id,\n    env_id: ctx.env_id,\n    step_id: newStepId,\n    at: Date.now(),\n    node,\n    status,\n    meta\n  })\n  \n  // Update state\n  nodeState.currentStatus = status === 'enter' ? 'entered' : (status === 'exit' ? 'exited' : 'errored')\n  nodeState.lastStepId = newStepId\n  traceState.lastStepId = newStepId\n  \n  return Object.freeze({ trace_id: ctx.trace_id, env_id: ctx.env_id, step_id: newStepId })\n}\n\nexport function replay(traceId: string): TraceRecord[] {\n  if (!traceId || typeof traceId !== 'string') {\n    throw new Error('replay: traceId must be a non-empty string')\n  }\n  \n  return log\n    .filter(x => x.trace_id === traceId)\n    .sort((a, b) => {\n      if (a.type === 'env') return -1\n      if (b.type === 'env') return 1\n      return ('step_id' in a ? a.step_id : 0) - ('step_id' in b ? b.step_id : 0)\n    })\n}\n\n", "/**\n * Storage - D1 Database Storage\n * \n * Handles storing webhook events to D1 database.\n * Follows trace.ts framework for consistent error tracking.\n */\n\nimport { step } from '../debug/trace'\nimport type { Context } from '../../types/types'\n\n// D1 Database type from Cloudflare Workers runtime\nexport interface StorageEnv {\n  DB: any  // D1Database type is available at runtime\n}\n\nexport interface StoredEvent {\n  id: string\n  trace_id: string\n  timestamp: string\n  method: string\n  url: string\n  pathname: string\n  ip?: string\n  user_agent?: string\n  headers: string  // JSON stringified\n  payload: string  // JSON stringified\n  content_type: string\n  processing_time_ms: number\n  created_at: number\n}\n\n/**\n * Store a webhook event to D1 database\n * \n * @param ctx - Trace context\n * @param env - Environment with DB binding\n * @param eventData - Event data to store\n * @returns Updated context\n */\nexport async function storeEvent(\n  ctx: Context,\n  env: StorageEnv,\n  eventData: {\n    url: string\n    method: string\n    pathname: string\n    headers: Record<string, string>\n    payload: unknown\n    contentType: string\n    processingTimeMs: number\n    ip?: string\n    userAgent?: string\n  }\n): Promise<Context> {\n  // Trace: entering store operation\n  ctx = step(ctx, 'store', 'enter')\n  \n  try {\n    // Generate unique ID for this event\n    const eventId = `evt_${Date.now()}_${Math.random().toString(36).slice(2)}`\n    const timestamp = new Date().toISOString()\n    const createdAt = Date.now()\n    \n    // Serialize complex objects to JSON\n    const headersJson = JSON.stringify(eventData.headers)\n    const payloadJson = JSON.stringify(eventData.payload)\n    \n    console.log('[STORAGE] Storing event:', {\n      eventId,\n      trace_id: ctx.trace_id,\n      pathname: eventData.pathname,\n      contentType: eventData.contentType\n    })\n    \n    // Insert into D1 database\n    const result = await env.DB.prepare(`\n      INSERT INTO webhook_events (\n        id,\n        trace_id,\n        timestamp,\n        method,\n        url,\n        pathname,\n        ip,\n        user_agent,\n        headers,\n        payload,\n        content_type,\n        processing_time_ms,\n        created_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      eventId,\n      ctx.trace_id,\n      timestamp,\n      eventData.method,\n      eventData.url,\n      eventData.pathname,\n      eventData.ip || null,\n      eventData.userAgent || null,\n      headersJson,\n      payloadJson,\n      eventData.contentType,\n      eventData.processingTimeMs,\n      createdAt\n    ).run()\n    \n    // Check if insert was successful\n    if (!result.success) {\n      throw new Error('D1 insert failed')\n    }\n    \n    console.log('[STORAGE] Event stored successfully:', {\n      eventId,\n      trace_id: ctx.trace_id,\n      rowsWritten: result.meta.rows_written\n    })\n    \n    // Trace: store operation completed successfully\n    ctx = step(ctx, 'store', 'exit', {\n      event_id: eventId,\n      rows_written: result.meta.rows_written\n    })\n    \n    return ctx\n    \n  } catch (error) {\n    console.error('[STORAGE] Failed to store event:', error)\n    \n    // Trace: store operation failed\n    ctx = step(ctx, 'store', 'error', {\n      error_code: 'STORAGE_FAILED',\n      reason: error instanceof Error ? error.message : String(error)\n    })\n    \n    throw error\n  }\n}\n\n/**\n * Initialize database schema\n * Call this once during setup to create the webhook_events table\n */\nexport async function initDatabase(db: any): Promise<void> {\n  await db.prepare(`\n    CREATE TABLE IF NOT EXISTS webhook_events (\n      id TEXT PRIMARY KEY,\n      trace_id TEXT NOT NULL,\n      timestamp TEXT NOT NULL,\n      method TEXT NOT NULL,\n      url TEXT NOT NULL,\n      pathname TEXT NOT NULL,\n      ip TEXT,\n      user_agent TEXT,\n      headers TEXT NOT NULL,\n      payload TEXT NOT NULL,\n      content_type TEXT NOT NULL,\n      processing_time_ms INTEGER NOT NULL,\n      created_at INTEGER NOT NULL\n    )\n  `).run()\n  \n  // Create index on trace_id for efficient lookups\n  await db.prepare(`\n    CREATE INDEX IF NOT EXISTS idx_webhook_events_trace_id \n    ON webhook_events(trace_id)\n  `).run()\n  \n  // Create index on created_at for chronological queries (RSS feed)\n  await db.prepare(`\n    CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at \n    ON webhook_events(created_at DESC)\n  `).run()\n  \n  // Create index on pathname for filtering by user/endpoint\n  await db.prepare(`\n    CREATE INDEX IF NOT EXISTS idx_webhook_events_pathname \n    ON webhook_events(pathname)\n  `).run()\n  \n  console.log('[STORAGE] Database schema initialized')\n}\n\n/**\n * Query webhook events from database\n * \n * @param env - Environment with DB binding\n * @param options - Query options (pathname, limit, offset)\n * @returns Array of stored events\n */\nexport async function queryEvents(\n  env: StorageEnv,\n  options: {\n    pathname?: string\n    trace_id?: string\n    limit?: number\n    offset?: number\n  } = {}\n): Promise<StoredEvent[]> {\n  const { pathname, trace_id, limit = 50, offset = 0 } = options\n  \n  let query = 'SELECT * FROM webhook_events'\n  const conditions: string[] = []\n  const params: any[] = []\n  \n  if (pathname) {\n    conditions.push('pathname = ?')\n    params.push(pathname)\n  }\n  \n  if (trace_id) {\n    conditions.push('trace_id = ?')\n    params.push(trace_id)\n  }\n  \n  if (conditions.length > 0) {\n    query += ' WHERE ' + conditions.join(' AND ')\n  }\n  \n  query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?'\n  params.push(limit, offset)\n  \n  const result = await env.DB.prepare(query).bind(...params).all()\n  \n  return result.results || []\n}\n\n", "/**\n * Handler - Webhook Ingress\n * \n * Entry point for webhook testing.\n * Parses incoming POST requests and returns acknowledgment.\n */\n\nimport { createEnv, step, replay } from '../debug/trace'\nimport type { Context } from '../../types/types'\nimport { storeEvent, queryEvents, type StorageEnv } from './storage'\n\n// In-memory storage removed - using D1 as source of truth\n\nexport async function handleRequest(request: Request, env: StorageEnv): Promise<Response> {\n  const startTime = Date.now()\n  const timestamp = new Date().toISOString()\n  let url = new URL(request.url)\n  \n  // Map /h/{slug} to /post/{slug} for compatibility\n  if (url.pathname.startsWith('/h/')) {\n    const newPathname = url.pathname.replace('/h/', '/post/')\n    url = new URL(url.origin + newPathname + url.search)\n  }\n  \n  // Handle database query endpoint: GET /events\n  if (request.method === 'GET' && url.pathname === '/events') {\n    try {\n      const searchParams = url.searchParams\n      const pathname = searchParams.get('pathname') || undefined\n      const trace_id = searchParams.get('trace_id') || undefined\n      const limit = parseInt(searchParams.get('limit') || '50')\n      const offset = parseInt(searchParams.get('offset') || '0')\n      \n      const events = await queryEvents(env, { pathname, trace_id, limit, offset })\n      \n      return new Response(JSON.stringify({ \n        ok: true,\n        count: events.length,\n        limit,\n        offset,\n        filters: { pathname, trace_id },\n        events\n      }, null, 2), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    } catch (error) {\n      return new Response(JSON.stringify({ \n        ok: false,\n        error: 'Failed to query events',\n        reason: error instanceof Error ? error.message : String(error)\n      }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    }\n  }\n  \n  // Handle trace replay endpoint: GET /trace/:trace_id\n  if (request.method === 'GET' && url.pathname.startsWith('/trace/')) {\n    const traceId = url.pathname.split('/')[2]\n    if (!traceId) {\n      return new Response(JSON.stringify({ error: 'trace_id required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    }\n    \n    try {\n      const traceRecords = replay(traceId)\n      if (traceRecords.length === 0) {\n        return new Response(JSON.stringify({ \n          error: 'Trace not found',\n          trace_id: traceId,\n          note: 'Traces are stored in-memory and cleared on worker restart'\n        }), {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n      \n      return new Response(JSON.stringify({ \n        trace_id: traceId,\n        records: traceRecords,\n        count: traceRecords.length\n      }, null, 2), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    } catch (error) {\n      return new Response(JSON.stringify({ \n        error: 'Failed to replay trace',\n        reason: error instanceof Error ? error.message : String(error)\n      }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    }\n  }\n  \n  // RSS feed functionality removed - was for outdated XML component\n  \n  // Handle GET /post/{slug} - return events from D1\n  if (request.method === 'GET' && url.pathname.startsWith('/post/')) {\n    // Query events from D1 database (persistent storage)\n    const events = await queryEvents(env, { pathname: url.pathname, limit: 50, offset: 0 })\n    \n    return new Response(JSON.stringify(events, null, 2), {\n      status: 200,\n      headers: { \n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      }\n    })\n  }\n  \n  // Create trace context\n  let ctx: Context = createEnv({\n    ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n    ua: request.headers.get('user-agent') || undefined,\n    headers: Object.fromEntries(request.headers.entries())\n  })\n  \n  // Only accept paths starting with /post (e.g., /post/user-slug)\n  if (!url.pathname.startsWith('/post')) {\n    return new Response('Not Found', {\n      status: 404,\n      headers: { 'Content-Type': 'text/plain' }\n    })\n  }\n\n  // Capture request headers\n  const headers = Object.fromEntries(request.headers.entries())\n\n  // Trace: parse request body\n  ctx = step(ctx, 'parse', 'enter')\n  \n  // Parse request body\n  const contentType = request.headers.get('content-type') || ''\n  let payload: unknown\n  let rawBody: string | undefined\n\n  try {\n    if (contentType.includes('application/json')) {\n      // JSON format\n      payload = await request.json()\n      console.log('[HANDLER] Parsed JSON payload:', payload)\n    } else if (contentType.includes('application/x-www-form-urlencoded')) {\n      // URL-encoded format\n      rawBody = await request.text()\n      payload = parseUrlEncoded(rawBody)\n      console.log('[HANDLER] Parsed URL-encoded payload:', payload)\n    } else {\n      // Try JSON first, fallback to URL-encoded\n      rawBody = await request.text()\n      try {\n        payload = JSON.parse(rawBody)\n        console.log('[HANDLER] Parsed as JSON (no content-type)')\n      } catch {\n        payload = parseUrlEncoded(rawBody)\n        console.log('[HANDLER] Parsed as URL-encoded (no content-type)')\n      }\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    \n    // Extract position info from SyntaxError if available\n    const positionMatch = errorMessage.match(/position (\\d+)/)\n    const position = positionMatch ? parseInt(positionMatch[1]) : undefined\n    \n    console.error('[HANDLER] Failed to parse body:', error)\n    \n    // Capture detailed error metadata for trace replay\n    ctx = step(ctx, 'parse', 'error', { \n      error_code: 'PARSE_FAILED', \n      reason: errorMessage,\n      content_type: contentType,\n      body_length: rawBody?.length,\n      error_position: position,\n      body_preview: rawBody ? rawBody.substring(0, 200) + (rawBody.length > 200 ? '...' : '') : undefined\n    })\n    \n    return new Response(\n      JSON.stringify({ \n        ok: false, \n        error: 'Failed to parse request body',\n        details: errorMessage,\n        trace_id: ctx.trace_id,\n        debug_url: `/trace/${ctx.trace_id}`\n      }),\n      { \n        status: 400, \n        headers: { 'Content-Type': 'application/json' }\n      }\n    )\n  }\n\n  // Trace: parse complete\n  ctx = step(ctx, 'parse', 'exit')\n\n  // Calculate processing time (before storage to capture accurate timing)\n  const processingTimeMs = Date.now() - startTime\n  const processingTime = `${processingTimeMs}ms`\n\n  // Events are stored in D1 database by storeEvent() below\n\n  // Store event to D1 database (async, for other features)\n  // Note: storeEvent() handles trace steps internally\n  try {\n    ctx = await storeEvent(ctx, env, {\n      url: request.url,\n      method: request.method,\n      pathname: url.pathname,\n      headers,\n      payload,\n      contentType,\n      processingTimeMs,\n      ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n      userAgent: request.headers.get('user-agent') || undefined\n    })\n  } catch (error) {\n    console.error('[HANDLER] Storage failed, continuing with response:', error)\n    // Storage error is already traced by storeEvent()\n    // We continue and return the response even if storage fails\n  }\n\n  // Return success with metadata\n  return new Response(\n    JSON.stringify({ \n      ok: true,\n      timestamp,\n      method: request.method,\n      status: 200,\n      processingTime,\n      headers,\n      payload,\n      trace_id: ctx.trace_id\n    }),\n    { \n      status: 200,\n      headers: { 'Content-Type': 'application/json' }\n    }\n  )\n}\n\n/**\n * Parse URL-encoded form data\n */\nfunction parseUrlEncoded(body: string): Record<string, string> {\n  const params = new URLSearchParams(body)\n  const result: Record<string, string> = {}\n  \n  for (const [key, value] of params.entries()) {\n    result[key] = value\n  }\n  \n  return result\n}\n\n", "/**\n * Durable Object - WebSocket Receiver\n * \n * Manages WebSocket connections per slug and broadcasts webhook events in real-time.\n * Integrates with D1 database for persistent storage and trace framework for debugging.\n */\n\nimport { StorageEnv, storeEvent, queryEvents } from './storage'\nimport { createEnv, step } from '../debug/trace'\nimport type { Context, PostbackEvent } from '../../types/types'\n\n// Cloudflare Workers types (available at runtime)\ndeclare const WebSocketPair: any\ninterface DurableObjectState {\n  storage: any\n  acceptWebSocket(ws: any): void\n}\ninterface DurableObjectNamespace {\n  idFromName(name: string): any\n  get(id: any): any\n}\ninterface ResponseInit {\n  status?: number\n  headers?: Record<string, string> | Headers\n  webSocket?: any\n}\n\n// Extended env with rate limiter and optional auth secret\nexport interface WebhookEnv extends StorageEnv {\n  RATE_LIMITER: DurableObjectNamespace\n  AUTH_SECRET?: string // Optional API key for unlimited usage\n}\n\nexport class WebhookReceiver {\n  state: DurableObjectState\n  env: WebhookEnv\n  sessions: Set<WebSocket> // For connection count logging\n  \n  constructor(state: DurableObjectState, env: WebhookEnv) {\n    this.state = state\n    this.env = env\n    this.sessions = new Set()\n    \n    console.log('[DO] WebhookReceiver initialized')\n  }\n  \n  // WebSocket close handler (called automatically by DO runtime)\n  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {\n    console.log(`[DO] WebSocket closed: code=${code}, reason=${reason}`)\n    this.sessions.delete(ws as any)\n  }\n  \n  // WebSocket error handler (called automatically by DO runtime)\n  async webSocketError(ws: WebSocket, error: any) {\n    console.log('[DO] WebSocket error:', error)\n    this.sessions.delete(ws as any)\n  }\n  \n  /**\n   * Extract user ID from request headers (Clerk or API key)\n   */\n  private getUserId(request: Request): string | null {\n    // Check for API key auth first (for unlimited usage)\n    const apiKey = request.headers.get('x-api-key') || request.headers.get('authorization')?.replace('Bearer ', '')\n    if (apiKey && this.env.AUTH_SECRET && apiKey === this.env.AUTH_SECRET) {\n      return 'api_authenticated' // Return special user ID for API auth\n    }\n    \n    // Clerk authentication\n    const authHeader = request.headers.get('authorization')\n    if (authHeader?.startsWith('Bearer ') && !this.env.AUTH_SECRET) {\n      // You'd decode the JWT here in production\n      return request.headers.get('x-clerk-user-id') || null\n    }\n    return request.headers.get('x-clerk-user-id') || null\n  }\n  \n  /**\n   * Get client IP address\n   */\n  private getIP(request: Request): string {\n    return request.headers.get('cf-connecting-ip') \n      || request.headers.get('x-forwarded-for') \n      || 'unknown'\n  }\n  \n  /**\n   * Check global rate limit (2 slugs per IP for anonymous users)\n   * Returns Response if rate limited, null if OK to proceed\n   */\n  private async checkGlobalRateLimit(request: Request, pathname: string): Promise<Response | null> {\n    const userId = this.getUserId(request)\n    const ip = this.getIP(request)\n    \n    // Extract slug from pathname (/h/123456 -> 123456)\n    const slug = pathname.split('/')[2]\n    \n    // Get global rate limiter DO (singleton)\n    const id = this.env.RATE_LIMITER.idFromName('global')\n    const stub = this.env.RATE_LIMITER.get(id)\n    \n    // Check with global rate limiter\n    const response = await stub.fetch('https://internal/check', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ ip, slug, userId })\n    })\n    \n    const result = await response.json() as {\n      allowed: boolean\n      slugCount: number\n      slugs?: string[]\n      reason?: string\n      resetAt?: number\n    }\n    \n    if (!result.allowed) {\n      console.log(`[DO] \u274C Global rate limit exceeded for IP ${ip}`)\n      \n      const resetDate = result.resetAt ? new Date(result.resetAt).toISOString() : 'unknown'\n      \n      return new Response(JSON.stringify({\n        error: 'Slug creation limit exceeded',\n        limit: 2,\n        current: result.slugCount,\n        slugs: result.slugs,\n        message: result.reason || 'You have reached the maximum number of webhook URLs for anonymous users.',\n        resetAt: resetDate,\n        suggestion: 'Sign in to create unlimited webhook URLs.'\n      }), {\n        status: 429,\n        headers: {\n          'Content-Type': 'application/json',\n          'Retry-After': String(24 * 60 * 60), // 24 hours in seconds\n          'X-RateLimit-Limit': '2',\n          'X-RateLimit-Remaining': '0',\n          'Access-Control-Allow-Origin': '*'\n        }\n      })\n    }\n    \n    console.log(`[DO] \u2705 Global rate limit OK: ${result.slugCount}/2 slugs used`)\n    \n    return null // OK to proceed\n  }\n  \n  /**\n   * Check rate limit before processing webhook\n   * Returns Response if rate limited, null if OK to proceed\n   */\n  private async checkRateLimit(request: Request): Promise<Response | null> {\n    const userId = this.getUserId(request)\n    const ip = this.getIP(request)\n    const identifier = userId || ip\n    \n    // Different limits for authenticated vs anonymous\n    const limit = userId ? 100 : 25\n    const window = 60 // seconds\n    \n    // Rate limit key: includes identifier and current minute\n    const currentMinute = Math.floor(Date.now() / (window * 1000))\n    const key = `ratelimit:${identifier}:${currentMinute}`\n    \n    // Get current count\n    const count = ((await this.state.storage.get(key)) as number) || 0\n    \n    console.log(`[DO] Rate limit check: ${identifier} (${userId ? 'authenticated' : 'anonymous'}) - ${count}/${limit}`)\n    \n    // Check if exceeded\n    if (count >= limit) {\n      console.log(`[DO] \u274C Rate limit exceeded for ${identifier}`)\n      return new Response(JSON.stringify({\n        error: 'Rate limit exceeded',\n        limit,\n        window: `${window} seconds`,\n        current: count,\n        retryAfter: window,\n        message: userId \n          ? `Authenticated users are limited to ${limit} requests per minute.`\n          : `Anonymous users are limited to ${limit} requests per minute. Sign in for higher limits.`\n      }), {\n        status: 429,\n        headers: {\n          'Content-Type': 'application/json',\n          'Retry-After': String(window),\n          'X-RateLimit-Limit': String(limit),\n          'X-RateLimit-Remaining': '0',\n          'X-RateLimit-Reset': String(Math.floor(Date.now() / 1000) + window),\n          'Access-Control-Allow-Origin': '*'\n        }\n      })\n    }\n    \n    // Increment counter with auto-expiration\n    await this.state.storage.put(key, count + 1, {\n      expirationTtl: window // Auto-cleanup after window expires\n    })\n    \n    console.log(`[DO] \u2705 Rate limit OK: ${count + 1}/${limit}`)\n    \n    return null // OK to proceed\n  }\n  \n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url)\n    \n    console.log(`[DO] ${request.method} ${url.pathname}`)\n    \n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      return new Response(null, {\n        status: 204,\n        headers: {\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n          'Access-Control-Allow-Headers': 'Content-Type',\n        },\n      })\n    }\n    \n    // Handle WebSocket upgrade\n    if (request.headers.get('Upgrade') === 'websocket') {\n      return this.handleWebSocket(request, url.pathname)\n    }\n    \n    // Handle POST webhook\n    if (request.method === 'POST') {\n      return this.handleWebhook(request, url.pathname)\n    }\n    \n    return new Response('Method not allowed', { status: 405 })\n  }\n  \n  async handleWebSocket(request: Request, pathname: string): Promise<Response> {\n    const pair = new WebSocketPair()\n    const [client, server] = Object.values(pair) as [any, any]\n    \n    this.state.acceptWebSocket(server)\n    this.sessions.add(server as WebSocket)\n    \n    console.log(`[DO] \u2705 WebSocket connected (${this.sessions.size} total sessions)`)\n    \n    // Send history from D1 to new client\n    try {\n      const events = await queryEvents(this.env, { pathname, limit: 50, offset: 0 })\n      \n      // Transform stored events to PostbackEvent format\n      const formattedEvents = events.map(e => ({\n        id: e.id,\n        trace_id: e.trace_id,\n        timestamp: e.timestamp,\n        method: e.method as any,\n        headers: JSON.parse(e.headers),\n        payload: JSON.parse(e.payload),\n        path: e.pathname,\n        ip: e.ip,\n        user_agent: e.user_agent\n      }))\n      \n      const historyMessage = {\n        type: 'history',\n        events: formattedEvents\n      }\n      \n      server.send(JSON.stringify(historyMessage))\n      console.log(`[DO] \uD83D\uDCE4 Sent ${formattedEvents.length} events to new client`)\n    } catch (err) {\n      console.error('[DO] Failed to load history:', err)\n      // Send empty history on error\n      server.send(JSON.stringify({ type: 'history', events: [] }))\n    }\n    \n    // Note: WebSocket close/error is handled by webSocketClose() and webSocketError() handlers\n    // No need for manual event listeners when using DO hibernation\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client\n    } as ResponseInit)\n  }\n  \n  async handleWebhook(request: Request, pathname: string): Promise<Response> {\n    // Global rate limit check FIRST (for anonymous users)\n    const globalRateLimitResponse = await this.checkGlobalRateLimit(request, pathname)\n    if (globalRateLimitResponse) {\n      return globalRateLimitResponse\n    }\n    \n    // Per-slug rate limiting check\n    const rateLimitResponse = await this.checkRateLimit(request)\n    if (rateLimitResponse) {\n      return rateLimitResponse\n    }\n    \n    // Create trace context\n    let ctx: Context = createEnv({\n      ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n      ua: request.headers.get('user-agent') || undefined,\n      headers: Object.fromEntries(request.headers.entries())\n    })\n    \n    ctx = step(ctx, 'receive', 'enter')\n    \n    const startTime = Date.now()\n    const contentType = request.headers.get('content-type') || ''\n    const headers = Object.fromEntries(request.headers.entries())\n    let payload: any\n    \n    try {\n      const body = await request.text()\n      \n      // Parse based on content type\n      if (contentType.includes('application/json')) {\n        payload = JSON.parse(body)\n      } else if (contentType.includes('application/x-www-form-urlencoded')) {\n        payload = parseUrlEncoded(body)\n      } else {\n        // Try JSON first, fallback to URL-encoded\n        try {\n          payload = JSON.parse(body)\n        } catch {\n          payload = parseUrlEncoded(body)\n        }\n      }\n      \n      ctx = step(ctx, 'receive', 'exit')\n    } catch (err) {\n      ctx = step(ctx, 'receive', 'error', { \n        error_code: 'PARSE_FAILED',\n        reason: err instanceof Error ? err.message : String(err)\n      })\n      \n      return new Response(JSON.stringify({ \n        ok: false,\n        error: 'Invalid payload',\n        trace_id: ctx.trace_id\n      }), { \n        status: 400,\n        headers: { \n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        }\n      })\n    }\n    \n    const processingTimeMs = Date.now() - startTime\n    \n    // Store to D1 database\n    try {\n      ctx = await storeEvent(ctx, this.env, {\n        url: request.url,\n        method: request.method,\n        pathname,\n        headers,\n        payload,\n        contentType,\n        processingTimeMs,\n        ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n        userAgent: request.headers.get('user-agent') || undefined\n      })\n    } catch (err) {\n      console.error('[DO] Storage failed:', err)\n      // Continue even if storage fails\n    }\n    \n    // Create event for broadcast\n    const event: PostbackEvent = {\n      id: ctx.trace_id,\n      trace_id: ctx.trace_id,\n      timestamp: new Date().toISOString(),\n      method: request.method as any,\n      headers,\n      payload,\n      path: pathname,\n      ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n      user_agent: request.headers.get('user-agent') || undefined\n    }\n    \n    // Broadcast to all connected WebSocket clients\n    // Use state.getWebSockets() to get hibernated connections\n    const connections = (this.state as any).getWebSockets()\n    const message = JSON.stringify(event)\n    let broadcastCount = 0\n    \n    console.log(`[DO] Found ${connections.length} WebSocket connections`)\n    \n    for (const ws of connections) {\n      try {\n        ws.send(message)\n        broadcastCount++\n      } catch (err) {\n        console.error('[DO] Failed to broadcast:', err)\n        // Connection will be auto-cleaned by DO runtime\n      }\n    }\n    \n    console.log(`[DO] \uD83D\uDCE1 Broadcasted to ${broadcastCount} client(s)`)\n    \n    return new Response(JSON.stringify({ \n      ok: true,\n      trace_id: ctx.trace_id,\n      broadcastCount,\n      timestamp: event.timestamp\n    }), {\n      headers: { \n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      }\n    })\n  }\n}\n\n/**\n * Parse URL-encoded form data\n */\nfunction parseUrlEncoded(body: string): Record<string, string> {\n  const params = new URLSearchParams(body)\n  const result: Record<string, string> = {}\n  \n  for (const [key, value] of params.entries()) {\n    result[key] = value\n  }\n  \n  return result\n}\n\n", "/**\n * Global Rate Limiter - Durable Object\n * \n * Tracks anonymous users (by IP) across all webhook slugs.\n * Enforces global limits:\n * - 2 unique slugs per IP for anonymous users\n * - Resets after 24 hours\n */\n\ninterface SlugUsage {\n  slug: string\n  firstUsed: number // timestamp\n  lastUsed: number  // timestamp\n}\n\ninterface IPRecord {\n  ip: string\n  slugs: SlugUsage[]\n  createdAt: number\n}\n\nexport class RateLimiter {\n  state: DurableObjectState\n  \n  constructor(state: DurableObjectState) {\n    this.state = state\n    console.log('[RateLimiter] Initialized')\n  }\n  \n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url)\n    \n    // Only accept POST requests for rate limit checks\n    if (request.method !== 'POST') {\n      return new Response('Method not allowed', { status: 405 })\n    }\n    \n    try {\n      const body = await request.json() as { ip: string, slug: string, userId?: string, checkOnly?: boolean }\n      const { ip, slug, userId, checkOnly } = body\n      \n      // Authenticated users bypass the global slug limit\n      if (userId) {\n        return new Response(JSON.stringify({ \n          allowed: true,\n          reason: 'authenticated'\n        }), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n      \n      // Check anonymous user's slug usage\n      const result = await this.checkIPLimit(ip, slug, checkOnly || false)\n      \n      return new Response(JSON.stringify(result), {\n        status: result.allowed ? 200 : 429,\n        headers: { \n          'Content-Type': 'application/json',\n          'X-RateLimit-Limit': '2',\n          'X-RateLimit-Remaining': String(Math.max(0, 2 - result.slugCount)),\n        }\n      })\n      \n    } catch (error) {\n      console.error('[RateLimiter] Error:', error)\n      return new Response(JSON.stringify({ \n        error: 'Invalid request',\n        allowed: false\n      }), { \n        status: 400,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    }\n  }\n  \n  /**\n   * Check if IP has exceeded slug creation limit\n   * @param checkOnly - If true, don't actually record the slug, just check\n   */\n  private async checkIPLimit(ip: string, slug: string, checkOnly: boolean = false): Promise<{\n    allowed: boolean\n    slugCount: number\n    slugs?: string[]\n    reason?: string\n    resetAt?: number\n  }> {\n    const key = `ip:${ip}`\n    const now = Date.now()\n    const RESET_WINDOW = 24 * 60 * 60 * 1000 // 24 hours\n    const MAX_SLUGS = 2\n    \n    // Get current IP record\n    let record = await this.state.storage.get(key) as IPRecord | undefined\n    \n    if (!record) {\n      // First time seeing this IP\n      if (checkOnly) {\n        // Don't create record for check-only\n        return {\n          allowed: true,\n          slugCount: 0,\n          slugs: []\n        }\n      }\n      \n      record = {\n        ip,\n        slugs: [{\n          slug,\n          firstUsed: now,\n          lastUsed: now\n        }],\n        createdAt: now\n      }\n      \n      await this.state.storage.put(key, record, {\n        expirationTtl: RESET_WINDOW / 1000 // 24 hours in seconds\n      })\n      \n      console.log(`[RateLimiter] New IP: ${ip} - slug: ${slug} (1/2)`)\n      \n      return {\n        allowed: true,\n        slugCount: 1,\n        slugs: [slug]\n      }\n    }\n    \n    // Clean up expired slugs (older than 24 hours)\n    const validSlugs = record.slugs.filter(s => now - s.firstUsed < RESET_WINDOW)\n    \n    // Check if this slug already exists for this IP\n    const existingSlug = validSlugs.find(s => s.slug === slug)\n    \n    if (existingSlug) {\n      if (!checkOnly) {\n        // Just update last used time\n        existingSlug.lastUsed = now\n        record.slugs = validSlugs\n        \n        await this.state.storage.put(key, record, {\n          expirationTtl: RESET_WINDOW / 1000\n        })\n        \n        console.log(`[RateLimiter] IP ${ip} reusing slug ${slug}`)\n      }\n      \n      return {\n        allowed: true,\n        slugCount: validSlugs.length,\n        slugs: validSlugs.map(s => s.slug)\n      }\n    }\n    \n    // New slug for this IP\n    if (validSlugs.length >= MAX_SLUGS) {\n      // Limit exceeded\n      const oldestSlug = validSlugs.sort((a, b) => a.firstUsed - b.firstUsed)[0]\n      const resetAt = oldestSlug.firstUsed + RESET_WINDOW\n      \n      console.log(`[RateLimiter] \u274C IP ${ip} exceeded limit (${validSlugs.length}/${MAX_SLUGS})`)\n      \n      return {\n        allowed: false,\n        slugCount: validSlugs.length,\n        slugs: validSlugs.map(s => s.slug),\n        reason: `Anonymous users are limited to ${MAX_SLUGS} unique webhook URLs per 24 hours. Sign in for unlimited webhooks.`,\n        resetAt\n      }\n    }\n    \n    // Add new slug\n    if (!checkOnly) {\n      validSlugs.push({\n        slug,\n        firstUsed: now,\n        lastUsed: now\n      })\n      \n      record.slugs = validSlugs\n      \n      await this.state.storage.put(key, record, {\n        expirationTtl: RESET_WINDOW / 1000\n      })\n      \n      console.log(`[RateLimiter] IP ${ip} added slug ${slug} (${validSlugs.length}/${MAX_SLUGS})`)\n    }\n    \n    return {\n      allowed: true,\n      slugCount: validSlugs.length,\n      slugs: validSlugs.map(s => s.slug)\n    }\n  }\n}\n\n", "// main worker file, keep light, put logic in core\n\nimport { createEnv, step } from './src/debug/trace'\nimport { handleRequest } from './src/shared/handler'\nimport type { StorageEnv } from './src/shared/storage'\n\n// Import and export Durable Object classes\nexport { WebhookReceiver } from './src/shared/reciever'\nexport { RateLimiter } from './src/shared/rate-limiter'\n\n// Cloudflare Workers types (available at runtime)\ninterface DurableObjectNamespace {\n  idFromName(name: string): any\n  get(id: any): any\n}\n\ninterface Fetcher {\n  fetch(request: Request): Promise<Response>\n}\n\n// Extend StorageEnv to include Durable Object bindings\nexport interface Env extends StorageEnv {\n  WEBHOOK_RECEIVER: DurableObjectNamespace\n  RATE_LIMITER: DurableObjectNamespace\n  ASSETS: Fetcher // Cloudflare Pages/Assets binding for React app\n  AUTH_SECRET?: string // Optional API key for unlimited webhook usage\n}\n\nexport default \n{\n  async fetch(request: Request, env: Env, context: any): Promise<Response> {\n    const url = new URL(request.url)\n    \n    // Handle rate limit check endpoint\n    if (url.pathname === '/h/rate-limit-check' && request.method === 'POST') {\n      const ip = request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || 'unknown'\n      const userId = request.headers.get('x-clerk-user-id') || null\n      \n      // Generate temporary slug for check\n      const tempSlug = 'check_' + Date.now()\n      \n      // Check with global rate limiter\n      const id = env.RATE_LIMITER.idFromName('global')\n      const stub = env.RATE_LIMITER.get(id)\n      \n      const response = await stub.fetch('https://internal/check', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ ip, slug: tempSlug, userId, checkOnly: true })\n      })\n      \n      const result = await response.json()\n      \n      return new Response(JSON.stringify(result), {\n        status: result.allowed ? 200 : 429,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        }\n      })\n    }\n    \n    // Check if this request should be routed to a Durable Object\n    const isWebSocket = request.headers.get('Upgrade') === 'websocket'\n    const isWebhookPath = url.pathname.startsWith('/h/') || url.pathname.startsWith('/post/')\n    \n    // Route WebSocket connections and POST webhooks to Durable Objects\n    if ((isWebSocket || request.method === 'POST') && isWebhookPath) {\n      console.log('[WORKER] Routing to Durable Object:', url.pathname)\n      \n      // Extract slug from path (/h/{slug} or /post/{slug})\n      const pathParts = url.pathname.split('/')\n      const slug = pathParts[2]\n      \n      if (!slug) {\n        return new Response(JSON.stringify({ error: 'Invalid slug' }), { \n          status: 400,\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n      \n      // Get or create Durable Object for this slug\n      const id = env.WEBHOOK_RECEIVER.idFromName(slug)\n      const stub = env.WEBHOOK_RECEIVER.get(id)\n      \n      // Forward request to Durable Object\n      return stub.fetch(request)\n    }\n    \n    // Handle other routes (GET /events, /trace/, GET /post/) with existing handler\n    // Create trace context for non-DO requests\n    let ctx = createEnv({\n      ip: request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || undefined,\n      ua: request.headers.get('user-agent') || undefined,\n      headers: Object.fromEntries(request.headers.entries())\n    })\n\n    // Trace: receive request\n    ctx = step(ctx, 'receive', 'enter')\n    \n    // Check URL for special endpoints\n    const isFeedRequest = url.pathname.includes('/feed')\n    const isTraceRequest = url.pathname.startsWith('/trace/')\n    const isEventsRequest = url.pathname === '/events'\n    const isPostRequest = url.pathname.startsWith('/post/')\n    \n    // Allow GET for post reads, feed, trace, and events\n    if (request.method === 'GET' && (isPostRequest || isFeedRequest || isTraceRequest || isEventsRequest)) {\n      // Valid request - pass to API handler\n      ctx = step(ctx, 'receive', 'exit')\n      console.log(ctx)\n      return handleRequest(request, env)\n    }\n    \n    // Serve React app for all other GET requests\n    if (request.method === 'GET') {\n      try {\n        // Try to fetch the requested asset (JS, CSS, images, etc.)\n        const assetResponse = await env.ASSETS.fetch(request)\n        \n        // If asset found, return it\n        if (assetResponse.status < 400) {\n          return assetResponse\n        }\n        \n        // If asset not found, return index.html (for React Router SPA routes)\n        // This handles routes like /docs, /pricing, /login, /signup, etc.\n        const indexRequest = new Request(new URL('/', request.url), request)\n        return env.ASSETS.fetch(indexRequest)\n      } catch (error) {\n        console.error('[WORKER] Asset serving error:', error)\n        return new Response('Error loading page', { \n          status: 500,\n          headers: { 'Content-Type': 'text/plain' }\n        })\n      }\n    }\n    \n    // Only reject if it's not a GET request and not a valid API endpoint\n    ctx = step(ctx, 'receive', 'error', { \n      error_code: 'METHOD_NOT_ALLOWED', \n      reason: `Method ${request.method} not supported for ${url.pathname}` \n    })\n    console.log(ctx)\n    return new Response('Method not allowed', {\n      status: 405,\n      headers: { 'Content-Type': 'text/plain' }\n    })\n  }\n}", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\deploy.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\deploy.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\.wrangler\\\\tmp\\\\bundle-1fb7cZ\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\.wrangler\\\\tmp\\\\bundle-1fb7cZ\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Users\\\\Local_Account\\\\Documents\\\\EFGH\\\\Posthook\\\\.wrangler\\\\tmp\\\\bundle-1fb7cZ\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["parseUrlEncoded"]
}
